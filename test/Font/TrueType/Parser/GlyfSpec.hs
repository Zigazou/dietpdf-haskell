module Font.TrueType.Parser.GlyfSpec
  ( spec
  ) where

import Control.Monad (forM_)

import Data.Binary.Parser (parseOnly)
import Data.ByteString (ByteString)

import Font.TrueType.FontTable.GlyphTable
  ( Glyph (EmptyGlyph)
  , GlyphHeader (GlyphHeader, ghNumberOfContours, ghXMax, ghXMin, ghYMax, ghYMin)
  , GlyphTable (GlyphTable)
  )
import Font.TrueType.FontTable.LocationTable (LocationTable (LocationTable))
import Font.TrueType.Parser.Glyf (glyphHeaderP, glyphP, singleGlyphP)

import Test.Hspec (Spec, describe, it, shouldBe)

glyphHeaderPExamples :: [(ByteString, GlyphHeader)]
glyphHeaderPExamples =
  [ ( "\x00\x05\x00\x64\x00\xC8\x01\x90\x02\x58"
    , GlyphHeader
        { ghNumberOfContours = 5
        , ghXMin = 100
        , ghYMin = 200
        , ghXMax = 400
        , ghYMax = 600
        }
    )
  , ( "\x00\x05\x00\x64\x00\x00\x03\x28\x05\xB0"
    , GlyphHeader
        { ghNumberOfContours = 5
        , ghXMin = 100
        , ghYMin = 0
        , ghXMax = 808
        , ghYMax = 1456
        }
    )
  , ( "\xFF\xFF\x00\x00\x00\x00\x01\x00\x01\x00"
    , GlyphHeader
        { ghNumberOfContours = -1  -- composite glyph
        , ghXMin = 0
        , ghYMin = 0
        , ghXMax = 256
        , ghYMax = 256
        }
    )
  ]

glyphPExamples :: [(ByteString, Glyph)]
glyphPExamples =
  [ ( ""  -- Empty glyph
    , EmptyGlyph
    )
  , ( "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"  -- Glyph with 0 contours
    , EmptyGlyph
    )
  ]

glyphTablePExamples :: [(String, ByteString, LocationTable, GlyphTable)]
glyphTablePExamples =
  [ ( "empty glyph table"
    , ""
    , LocationTable []
    , GlyphTable []
    )
  , ( "one empty glyph"
    , "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"  -- One empty glyph
    , LocationTable [0]
    , GlyphTable [EmptyGlyph]
    )
  , ( "one glyph"
    , "\x00\x05\x00\x64\x00\x00\x03\x28\x05\xB0\x00\x03\x00\x06\x00\x09\x00\x0C\
      \\x00\x0F\x00\x50\x00\xB0\x00\x45\x58\xB0\x02\x2F\x1B\xB1\x02\x1F\x3E\x59\
      \\xB0\x00\x45\x58\xB0\x00\x2F\x1B\xB1\x00\x0F\x3E\x59\xB2\x04\x02\x00\x11\
      \\x12\x39\xB2\x05\x02\x00\x11\x12\x39\xB2\x07\x02\x00\x11\x12\x39\xB2\x08\
      \\x02\x00\x11\x12\x39\xB0\x0A\xDC\xB2\x0C\x02\x00\x11\x12\x39\xB2\x0D\x02\
      \\x00\x11\x12\x39\xB0\x02\x10\xB0\x0E\xDC\x30\x31\x21\x21\x11\x21\x03\x11\
      \\x01\x01\x11\x01\x03\x21\x01\x35\x01\x21\x03\x28\xFD\x3C\x02\xC4\x36\xFE\
      \\xEE\xFE\xBA\x01\x0C\xE4\x02\x03\xFE\xFE\x01\x02\xFD\xFD\x05\xB0\xFA\xA4\
      \\x05\x07\xFD\x7D\x02\x77\xFB\x11\x02\x78\xFD\x5E\x02\x5E\x88\x02\x5E\x00\
      \\x00\x02\x00\x67\xFF\xEE\x01\xDD\x05\xB0\x00\x03\x00\x0C\x00\x3C\xB2\x06\
      \\x0D\x0E\x11\x12\x39\xB0\x06\x10\xB0\x01\xD0\x00\xB0\x00\x45\x58\xB0\x02\
      \\x2F\x1B\xB1\x02\x1F\x3E\x59\xB0\x00\x45\x58\xB0\x0B\x2F\x1B\xB1\x0B\x0F\
      \\x3E\x59\xB1\x06\x06\xB0\x0A\x2B\x58\x21\xD8\x1B\xF4\x59\xB0\x01\xD0\xB0\
      \\x01\x2F\x30\x31\x01\x21\x03\x21\x01\x34\x36\x32\x16\x14\x06\x22\x26\x01\
      \\xAD\xFE\xEF\x2B\x01\x67\xFE\x8F\x6B\xA0\x6B\x6B\xA0\x6B\x01\xCD\x03\xE3\
      \\xFA\xE7\x4A\x5F\x5F\x94\x5F\x5F\x00\x02\x00\x19\x03\xC9\x02\x5E\x06\x01\
      \\x00\x04\x00\x09\x00\x26\xB2\x04\x0A\x0B\x11\x12\x39\xB0\x04\x10\xB0\x08\
      \\xD0\x00\xB0\x03\x2F\xB2\x02\x0A\x03\x11\x12\x39\xB0\x02\x2F\xB0\x07\xD0\
      \\xB0\x03\x10\xB0\x08\xD0\x30\x31\x13\x03\x23\x11\x33\x05\x03\x23\x11\x33\
      \\xFF\x2B\xBB\xE6\x01\x5F\x2B\xB9\xE4\x05\x76\xFE\x53\x02\x38\x8B\xFE\x53\
      \\x02\x38\x00\x02\x00\x1E\x00\x00\x04\x7A\x05\xB0\x00\x1B\x00\x1F\x00\x9C\
      \\xB2\x1F\x20\x21\x11\x12\x39\xB0\x1F\x10\xB0\x0E\xD0\x00\xB0\x00\x45\x58\
      \\xB0\x0C\x2F\x1B\xB1\x0C\x1F\x3E\x59\xB0\x00\x45\x58\xB0\x10\x2F\x1B\xB1\
      \\x10\x1F\x3E\x59\xB0\x00\x45\x58\xB0\x02\x2F\x1B\xB1\x02\x0F\x3E\x59\xB0\
      \\x00\x45\x58\xB0\x1A\x2F\x1B\xB1\x1A\x0F\x3E\x59\xB2\x1D\x0C\x02\x11\x12\
      \\x39\xB0\x1D\x2F\xB1\x00\x07\xB0\x0A\x2B\x58\x21\
      \                                                               "
    , LocationTable [ 0x0000 ]
    , GlyphTable []
    )
  ]

spec :: Spec
spec = do
  describe "glyphHeaderP" $ do
    forM_ glyphHeaderPExamples $ \(source, expected) ->
      it ("decodes glyph header " ++ show source) $ do
        parseOnly glyphHeaderP source `shouldBe` Right expected

  describe "singleGlyphP" $ do
    forM_ glyphPExamples $ \(source, expected) ->
      it ("decodes glyph " ++ show source) $ do
        parseOnly singleGlyphP source `shouldBe` Right expected

  describe "glyphP" $ do
    forM_ glyphTablePExamples $ \(description, source, locTable, expected) ->
      it ("decodes glyph table " ++ show description) $ do
        parseOnly (glyphP locTable) source `shouldBe` Right expected
