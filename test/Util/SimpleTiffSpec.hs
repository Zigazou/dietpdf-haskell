module Util.SimpleTiffSpec
  ( spec
  ) where

import Control.Monad.Except (runExceptT)
import Control.Monad.Trans (lift)
import Control.Monad.Trans.Except (throwE)

import Data.ByteString (ByteString)
import Data.ByteString qualified as BS
import Data.ColorSpace (ColorSpace (ColorSpaceGray, ColorSpaceRGB))
import Data.Fallible (Fallible, FallibleT)
import Data.UnifiedError (UnifiedError (ExternalCommandError))

import GHC.IO.Exception (ExitCode (ExitFailure, ExitSuccess))
import GHC.IO.Handle
  (BufferMode (BlockBuffering), Handle, hClose, hSetBinaryMode, hSetBuffering)

import System.IO.Temp (withSystemTempFile)
import System.Process.Extra
  ( ProcessHandle
  , StdStream (CreatePipe)
  , proc
  , waitForProcess
  , withCreateProcess
  )
import System.Process.Internals (CreateProcess (std_out))

import Test.Hspec (Spec, describe, it, shouldBe)

import Util.SimpleTiff (simpleTiff)

{-|
Runs an external command with the given arguments and input.

If the command fails, this function throws an `ExternalCommandError` error.

The input is written to a file that is then given in the command's arguments.
The output is captured and returned.
-}
externalCommandBuf'
  :: FilePath
  -> [String]
  -> ByteString
  -> FallibleT IO ByteString
externalCommandBuf' command args input = do
  withSystemTempFile "dietpdf.temporary" $ \temp tempHandle -> do
    lift $ hClose tempHandle
    lift $ BS.writeFile temp input
    let process = (proc command (args ++ [temp])) { std_out = CreatePipe }

    result <- lift $ withCreateProcess process injectInput

    case result of
      Right output -> return output
      Left err     -> throwE err
 where
  injectInput
    :: Maybe Handle
    -> Maybe Handle
    -> Maybe Handle
    -> ProcessHandle
    -> IO (Fallible ByteString)
  injectInput _stdin (Just stdout) _stderr ph = do
    -- Configure stdout
    hSetBinaryMode stdout True
    hSetBuffering stdout (BlockBuffering Nothing)

    -- Read stdout and stderr
    output   <- BS.hGetContents stdout
    exitCode <- waitForProcess ph

    case exitCode of
      ExitSuccess    -> return $ Right output
      ExitFailure rc -> return $ Left (ExternalCommandError command rc)
  injectInput _ _ _ _ =
    return $ Left (ExternalCommandError (command ++ ": invalid handles") 1)


rgbImage :: ByteString
rgbImage = BS.pack
  [ 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF
  , 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00
  , 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF
  , 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00
  , 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF
  , 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00
  , 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF
  , 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00
  , 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF
  ]

pnmRgbImage :: ByteString
pnmRgbImage = BS.concat ["P6\n", "4 9\n", "255\n", rgbImage]

grayImage :: ByteString
grayImage = BS.pack
  [ 0x40, 0x80, 0x00, 0xFF
  , 0xFF, 0x00, 0xFF, 0x00
  , 0x40, 0x80, 0x00, 0xFF
  , 0xFF, 0x00, 0xFF, 0x00
  , 0x40, 0x80, 0x00, 0xFF
  , 0xFF, 0x00, 0xFF, 0x00
  , 0x40, 0x80, 0x00, 0xFF
  , 0xFF, 0x00, 0xFF, 0x00
  , 0x40, 0x80, 0x00, 0xFF
  ]

pnmGrayImage :: ByteString
pnmGrayImage = BS.concat ["P5\n", "4 9\n", "255\n", grayImage]

{-
cmykImage :: ByteString
cmykImage = BS.pack
  [ 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00
  , 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00
  , 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00
  , 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00
  , 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00
  , 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00
  , 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00
  , 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00
  , 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00
  ]

pnmCmykImage :: ByteString
pnmCmykImage = BS.concat ["P6\n", "4 9\n", "255\n", cmykImage]
-}

spec :: Spec
spec = do
  describe "simpleTiff" $ do
    it "creates a simple RGB TIFF file" $ do
      let tiff = simpleTiff 4 9 ColorSpaceRGB rgbImage
      raw <- runExceptT $ externalCommandBuf' "tifftopnm" [ "-quiet"] tiff
      raw `shouldBe` Right pnmRgbImage

    it "creates a simple Grayscale TIFF file" $ do
      let tiff = simpleTiff 4 9 ColorSpaceGray grayImage
      raw <- runExceptT $ externalCommandBuf' "tifftopnm" [ "-quiet"] tiff
      raw `shouldBe` Right pnmGrayImage

    {-
    it "creates a simple CMYK TIFF file" $ do
      let tiff = simpleTiff 4 9 4 cmykImage
      raw <- runExceptT $ externalCommandBuf' "tifftopnm" [ "-quiet"] tiff
      raw `shouldBe` Right pnmCmykImage
    -}
