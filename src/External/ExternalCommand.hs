module External.ExternalCommand
  ( externalCommand
  , externalCommandBuf
  , externalCommandBuf'
  , externalCommandBuf''
  )
where

import Control.Monad.Trans.Class (lift)
import Control.Monad.Trans.Except (throwE)

import Data.ByteString (ByteString)
import Data.ByteString qualified as BS
import Data.Fallible (Fallible, FallibleT)
import Data.UnifiedError (UnifiedError (ExternalCommandError))

import GHC.IO.Handle
    ( BufferMode (BlockBuffering)
    , Handle
    , hClose
    , hSetBinaryMode
    , hSetBuffering
    )

import System.Exit (ExitCode (ExitFailure, ExitSuccess))
import System.IO.Temp (withSystemTempFile)
import System.Process
    ( StdStream (CreatePipe)
    , proc
    , readProcessWithExitCode
    , waitForProcess
    , withCreateProcess
    )
import System.Process.Internals (CreateProcess (std_in, std_out), ProcessHandle)

{- |
Runs an external command with the given arguments.

If the command fails, this function throws an `ExternalCommandError` error.

It ignores the output of the command.
-}
externalCommand :: FilePath -> [String] -> FallibleT IO ()
externalCommand command args = do
  (exitCode, _, _) <- lift $ readProcessWithExitCode command args ""

  case exitCode of
    ExitSuccess    -> return ()
    ExitFailure rc -> throwE (ExternalCommandError (show args) rc)

{- |
Runs an external command with the given arguments and input.

If the command fails, this function throws an `ExternalCommandError` error.

The input is passed to the command's stdin, and the output is captured and
returned.

For unknown reason, this function may fail with some commands. If you encounter
such a problem, try using `externalCommandBuf' or externalCommandBuf'' instead.
-}
externalCommandBuf
  :: FilePath
  -> [String]
  -> ByteString
  -> FallibleT IO ByteString
externalCommandBuf command args input = do
  let process = (proc command args) { std_in  = CreatePipe
                                    , std_out = CreatePipe
                                    }

  result <- lift $ withCreateProcess process (injectInput input)

  case result of
    Right output -> return output
    Left err     -> throwE err
 where
  injectInput
    :: ByteString
    -> Maybe Handle
    -> Maybe Handle
    -> Maybe Handle
    -> ProcessHandle
    -> IO (Fallible ByteString)
  injectInput input' (Just stdin) (Just stdout) _stderr ph = do
    -- Configure stdin
    hSetBinaryMode stdin True
    hSetBuffering stdin (BlockBuffering Nothing)

    -- Configure stdout
    hSetBinaryMode stdout True
    hSetBuffering stdout (BlockBuffering Nothing)

    -- Write input to stdin
    BS.hPut stdin input'
    hClose stdin

    -- Read stdout and stderr
    output   <- BS.hGetContents stdout
    exitCode <- waitForProcess ph

    case exitCode of
      ExitSuccess    -> return $ Right output
      ExitFailure rc -> return $ Left (ExternalCommandError command rc)
  injectInput _ _ _ _ _ =
    return $ Left (ExternalCommandError (command ++ ": invalid handles") 1)

{- |
Runs an external command with the given arguments and input.

If the command fails, this function throws an `ExternalCommandError` error.

The input is written to a file that is then given in the command's arguments.
The output is captured and returned.
-}
externalCommandBuf'
  :: FilePath
  -> [String]
  -> ByteString
  -> FallibleT IO ByteString
externalCommandBuf' command args input = do
  withSystemTempFile "dietpdf.temporary" $ \temp tempHandle -> do
    lift $ hClose tempHandle
    lift $ BS.writeFile temp input
    let process = (proc command (args ++ [temp])) { std_out = CreatePipe }

    result <- lift $ withCreateProcess process injectInput

    case result of
      Right output -> return output
      Left err     -> throwE err
 where
  injectInput
    :: Maybe Handle
    -> Maybe Handle
    -> Maybe Handle
    -> ProcessHandle
    -> IO (Fallible ByteString)
  injectInput _stdin (Just stdout) _stderr ph = do
    -- Configure stdout
    hSetBinaryMode stdout True
    hSetBuffering stdout (BlockBuffering Nothing)

    -- Read stdout and stderr
    output   <- BS.hGetContents stdout
    exitCode <- waitForProcess ph

    case exitCode of
      ExitSuccess    -> return $ Right output
      ExitFailure rc -> return $ Left (ExternalCommandError command rc)
  injectInput _ _ _ _ =
    return $ Left (ExternalCommandError (command ++ ": invalid handles") 1)

insertFileNames :: [String] -> [FilePath] -> [String]
insertFileNames [] _ = []
insertFileNames args [] = args
insertFileNames ("-":args) (fileName:fileNames) =
  fileName : insertFileNames args fileNames
insertFileNames (arg:args) fileNames = arg : insertFileNames args fileNames

{- |
Runs an external command with the given arguments and input.

If the command fails, this function throws an `ExternalCommandError` error.

The input is written to a file that is then given in the command's arguments.
The output is read from a file generated by the command.
-}
externalCommandBuf''
  :: FilePath
  -> [String]
  -> String
  -> String
  -> ByteString
  -> FallibleT IO ByteString
externalCommandBuf'' command args inputExt outputExt input = do
  let inputTemplate  = "dietpdf." ++ inputExt
      outputTemplate = "dietpdf." ++ outputExt

  withSystemTempFile inputTemplate $ \tempIn tempInHandle -> do
    withSystemTempFile outputTemplate $ \tempOut tempOutHandle -> do
      lift $ hClose tempInHandle
      lift $ hClose tempOutHandle
      lift $ BS.writeFile tempIn input

      let args' = insertFileNames args [tempIn, tempOut]
      (exitCode, _, _) <- lift $ readProcessWithExitCode command args' ""

      case exitCode of
        ExitSuccess    -> lift $ BS.readFile tempOut
        ExitFailure rc -> throwE (ExternalCommandError (show args') rc)
